from pydantic import BaseModel, ConfigDict, Field, field_serializer
from typing import List, Dict, Any, Optional, Literal
from bson.decimal128 import Decimal128

# Import the DBConnectionParams from its new location
from src.models.db import DBConnectionParams
from src.models.chat_history import ChatHistory


# Accepts user question and now includes the connections
class NLQueryRequest(BaseModel):
    question: str
    model_provider: Optional[str] = Field(None)
    connections: List[DBConnectionParams] = []
    chat_history: List[ChatHistory] = []

    model_config = ConfigDict(extra="forbid")


# Final Response of the api
class FinalResponse(BaseModel):
    success: bool
    response_type: Literal["query_result", "analysis_result", "general_answer", "dangerous_question"] = Field(
        "query_result",
        description="The type of response generated ('query_result', 'analysis_result', 'general_answer')."
    )
    analysis: str = Field(..., description="A detailed, markdown-formatted text analysis of the results.")
    
    # Optional fields, primarily for 'query_result' type
    generated_query: Optional[Dict[str, Any]] = Field(None, description="The query plan generated by the AI to fetch the data.")
    execution_time_ms: Optional[int] = Field(None, description="Total time taken to process the request in milliseconds.")
    data: Optional[List[Dict[str, Any]]] = Field(None, description="A list of data tables, each a dictionary with columns and rows.")
    visualization: Optional[Dict[str, Dict[str, Any]]] = Field(None, description="A dictionary suggesting appropriate visualizations for each data table.")
    table_desc: Optional[Dict[str, str]] = Field(None, description="A dictionary providing a one-line description for each data table.")
    error_message: Optional[str] = Field(None, description="Contains an error message if success is false.")
    
    model_config = ConfigDict(extra="forbid")

    @field_serializer('data')
    def serialize_data(self, data: Optional[List[Dict[str, Any]]]) -> Optional[List[Dict[str, Any]]]:
        """
        Recursively finds and converts Decimal128 instances to strings
        in the data payload to ensure JSON compatibility.
        """
        if data is None:
            return None
            
        def convert_recursively(obj):
            if isinstance(obj, list):
                return [convert_recursively(item) for item in obj]
            if isinstance(obj, dict):
                return {key: convert_recursively(value) for key, value in obj.items()}
            # This is the core conversion logic
            if isinstance(obj, Decimal128):
                return str(obj)
            return obj

        return convert_recursively(data)
